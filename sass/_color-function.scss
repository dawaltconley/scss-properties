@use 'sass:color';
@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use 'sass:meta';
@use 'var';
@use 'utils';
@use 'color' as sass-color;

@function _compatible($value, $property, $type: null) {
  $unit: map.get(var.$PROPERTIES, $property, 'unit');
  $isNumber: meta.type-of($value) == 'number';
  $unitTest: $isNumber and math.is-unitless($value);
  @if ($isNumber and not math.is-unitless($unit)) {
    $unitTest: $unitTest or math.compatible($value, $unit);
  }
  @if ($isNumber) {
    $min: map.get(var.$PROPERTIES, $property, 'min');
    $max: map.get(var.$PROPERTIES, $property, 'max');
    $allowNegative: $type and $type == var.$ADJUST or $type == var.$SCALE;
    $rangeValue: if($allowNegative, math.abs($value), $value);
    $unitTest: $unitTest and $min < $rangeValue and $rangeValue < $max;
  }
  @return meta.type-of($value) == 'string' or $unitTest;
}

@function _validate($colors, $propValues: (), $type: null) {
  @each $colorName in $colors {
    @if not (meta.type-of($colorName) == 'string' and map.has-key(var.$COLORS, $colorName)) {
      @error '#{$colorName} is not a defined color.';
    }
  }
  @each $prop, $value in $propValues {
    @if $value and not _compatible($value, $prop, $type) {
      @error 'Invalid #{$prop} value for #{$type} function: #{$value}';
    }
  }
  @return true;
}

@function _invertHue($colorName1, $colorName2) {
  $color1: map.get(var.$COLORS, $colorName1, 'color');
  $color2: map.get(var.$COLORS, $colorName2, 'color');
  @return math.abs(color.hue($color1) - color.hue($color2)) > 180deg;
}

// also allow mixing different values by different weights?
@function mix($colorName1, $colorName2, $weight: 50%, $hue: null, $saturation: null, $lightness: null, $alpha: null, $invert-hue: null) {
  $valid: _validate(($colorName1, $colorName2), ('weight' $weight, 'weight' $hue, 'weight' $saturation, 'weight' $lightness, 'weight' $alpha), $type: 'mix');
  $invert: _invertHue($colorName1, $colorName2);
  $invert: if($invert-hue, not $invert, $invert);
  @return sass-color.makeHSL(
    $hue:         utils.calcMix($colorName1, $colorName2, $hue or $weight, var.$HUE, $modify: $invert and -360deg),
    $saturation:  utils.calcMix($colorName1, $colorName2, $saturation or $weight, var.$SATURATION),
    $lightness:   utils.calcMix($colorName1, $colorName2, $lightness or $weight, var.$LIGHTNESS),
    $alpha:       utils.calcMix($colorName1, $colorName2, $alpha or $weight, var.$ALPHA),
  );
}

@function _calcProperties($colorName, $function, $args...) {
  $kwargs: meta.keywords($args);
  $valid: _validate($colorName, $kwargs, $function);
  $ops: ();
  @each $property, $value in $kwargs {
    @if $value {
      $ops: map.set($ops, $property, utils.calcProperty($value, $colorName, $property, $function));
    }
  }
  @return $ops;
}

@function _calcHSL($colorName, $function, $args...) {
  $properties: _calcProperties($colorName, $function, $args...);
  $defaults: map.get(var.$COLORS, $colorName, 'defaults');
  $properties: map.merge($defaults, $properties);
  @return sass-color.makeHSL($properties...);
}

@function adjust($colorName, $hue: null, $saturation: null, $lightness: null, $alpha: null) {
  @return _calcHSL($colorName, var.$ADJUST, $hue: $hue, $saturation: $saturation, $lightness: $lightness, $alpha: $alpha);
}

@function change($colorName, $hue: null, $saturation: null, $lightness: null, $alpha: null) {
  @return _calcHSL($colorName, var.$CHANGE, $hue: $hue, $saturation: $saturation, $lightness: $lightness, $alpha: $alpha);
};

@function scale($colorName, $saturation: null, $lightness: null, $alpha: null) {
  @return _calcHSL($colorName, var.$SCALE, $saturation: $saturation, $lightness: $lightness, $alpha: $alpha);
};

@function _parseSetArg($arg) {
  $property: map.has-key(var.$PROPERTIES, $arg) and $arg;
  $func: list.index(var.$FUNCTIONS, $arg) and $arg;
  @if not $property and not $func {
    @error 'Bad argument for set function: #{$arg}';
  }
  @return $property, $func;
}

// could simplify if I changed the previous function outputs and used meta.call
@function _getOperation($colorName, $property: null, $type: null, $settings: null) {
  @if not $property {
    @error 'Must specify color property: #{$property} #{$type} #{$settings}';
  }
  @if not $type {
    @error 'Must specify modification type: #{$property} #{$type} #{$settings}';
  }
  @if $type == 'mix' {
    $colorName2: list.nth($settings, 1); // allow map as well
    $weight: list.nth($settings, 2) or 50%;
    $valid: _validate(($colorName, $colorName2), ('weight': $weight), $type: 'mix');
    $invert: $property == var.$HUE and _invertHue($colorName, $colorName2);
    // invert option
    @return utils.calcMix($colorName, $colorName2, $weight, $property, $modify: $invert and -360deg);
  } @else {
    $param: list.nth($settings, 1);
    $valid: _validate($colorName, (#{$property}: $param), $type);
    @return utils.calcProperty($param, $colorName, $property, $type);
  }
}

@function set($colorName, $setMap: null, $argList...) {
  @if not $setMap {
    @return set($colorName, meta.keywords($argList));
  }

  $ops: ();
  @each $key1, $value in $setMap {
    $arg1: _parseSetArg($key1);
    @if meta.type-of($value) == 'list' and meta.type-of(list.nth($value, 1) != 'list') {
      $settings: ();
      @for $i from 2 through list.length($value) {
        $settings: list.append($settings, list.nth($value, $i));
      }
      $value: (#{list.nth($value, 1)}: $settings);
    }
    // @if meta.type-of($value) == 'map' {
    //   $value: list.zip(map.keys($value), map.values($value));
    // }
    @each $key2, $settings in $value {
      $arg2: _parseSetArg($key2);
      $property: list.nth($arg1, 1) or list.nth($arg2, 1);
      $type: list.nth($arg1, 2) or list.nth($arg2, 2);
      $ops: map.set($ops, $property, _getOperation($colorName, $property, $type, $settings));
    }
  }

  $defaults: map.get(var.$COLORS, $colorName, 'defaults');
  $properties: map.merge($defaults, $ops);
  @return sass-color.makeHSL($properties...);
}

@mixin define($colorMap, $parent: '', $forceAlpha: true) {
  @if (meta.type-of($colorMap) == 'map') {
    @each $colorName in map.keys($colorMap) {
      $name: #{$parent}#{$colorName};
  
      @if ($colorName == 'color') {
        $name: #{$parent};
      }
  
      $color: map.get($colorMap, $colorName);
  
      $isColor: meta.type-of($color) == 'color';
      $isMap: meta.type-of($color) == 'map';
      $isAlpha: $forceAlpha or ($isColor and color.alpha($color) != 1);
  
      @if ($isMap) {
        @include define($color, $parent: $name);
      } @else if ($isColor) {
        $name-h: #{$name}#{var.$POSTFIX-HUE};
        $name-s: #{$name}#{var.$POSTFIX-SATURATION};
        $name-l: #{$name}#{var.$POSTFIX-LIGHTNESS};
        $name-a: #{$name}#{var.$POSTFIX-ALPHA};
  
        $defaults: (
          #{var.$HUE}: var($name-h),
          #{var.$SATURATION}: var($name-s),
          #{var.$LIGHTNESS}: var($name-l)
        );
        @if ($isAlpha) {
          $defaults: map.set($defaults, var.$ALPHA, var($name-a));
        }
  
        #{$name}: sass-color.makeHSL($defaults...);
        #{$name-h}: color.hue($color);
        #{$name-s}: color.saturation($color);
        #{$name-l}: color.lightness($color);
        @if ($isAlpha) {
          #{$name-a}: color.alpha($color);
        }

        var.$COLORS: map.set(var.$COLORS, $name, (
          'color': $color,
          'alpha': $isAlpha,
          'defaults': $defaults
        ));
      } @else {
        #{$name}: $color;
      }
    }
  }
}
